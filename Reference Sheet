tipos de dados:
string - inferem sequência de letras, "" VERMELHO (Cor do IntelliSense)
char - infere um único caractere, '' VERMELHO (Cor do IntelliSense)
números - infere um número tipo integral, () (o parênteses pode ser 
      omitido) VERDE (Cor do IntelliSense)
      L tipos de números assinalados:
         sbyte: -128 a 127
         short: -32768 a 32767
         int: -2147483648 a 2147483647
         long: -9223372036854775808 a 9223372036854775807
      L tipos de números não assinalados:
         byte: 0 a 255
         ushort: 0 a 65535
         uint: 0 a 4294967295
         ulong: 0 a 18446744073709551615
      L tipos de números flutuantes (com casas decimais)
         Float: -3,4028235E+38 a 3,4028235E+38 (precisão de 9 casas)
         Double: -1,7976931348623157E+308 a 1,7976931348623157E+308 (precisão
                 de 17 casas)
         Decimal: -79228162514264337593543950335 a 
                  79228162514264337593543950335 (precisão de 29 casas)

coerção: técnica para converter tipos de dados:
         L conversão de expansão: baixa precisão > alta precisão
            e.g.: int > long

                  int myInt = 0;
                  long x = (long)myInt;

         L conversão de restrição: alta precisão > baixa precisão
            e.g.: decimal > int

                  decimal myDecimal: 1.23456789m;
                  int myInt = (int)myDecimal;

            (acarreta em possível perda de precisão)

var - variável genérica e adaptável a qualquer tipo de dado

formatação de Hard-Code
\n - Enter
\t - tab
\" Lorem ipsum \" - usar aspas duplas dentro do código
\\ Lorem ipsum \\ - usar barras invertidas dentro do código
@ - verbatim, ignora a maioria dos caracteres de escapes para aumentar a 
    legibilidade, além de preservar espaços.
  L nota: "duplicar ""aspas duplas"" para usá-lo"
$ - interpolação - utiliza-se para mencionar variáveis entre chaves {}
  L nota: deve precede o verbatim, caso houver
+ - adição ou concatenação
- - subtração
+= - soma o mesmo elemento com mais algo
-= - subrtrai o mesmo elemento com algo
++ - shortcut para += 1
-- - shortcut para -= 1
/ - divisão (cuidado, usar float, double ou decimal)
/= divide o mesmo elemento com algo
* - multiplicação 
*= multiplica o mesmo elemento com algo
% - cálculo do resto da divisão dos números
= - atribuição
== - checa igualdades
!= - checa desigualdades
> - compara o termo da esquerda, supondo ele maior que o da direita
< - compara o termo da esquerda, supondo ele menor que o da direita
? - Feita a comparação, o resultado "True" atribui o resultado que o sucede
: - Feita a comparação, o resultado "False" atribui o resultado que o sucede.
  L ":" vem depois de "?"
|| - ou, serve apenas para comparações booleanas
&& - e, serve apenas para comparações booleanas
! - não, serve apenas para comparações booleanas
or - patter matching lógico ou, para switch cases 
and - patter matching lógico e, para switch cases 
not - patter matching lógico não, para switch cases
?? - operador de coalescência, ele atribui um valor padrão para um input nulo

convenções

variável: escrever no estilo camelCase (primeira letra minúscula, e, a cada
          palavra nova, separação não por espaço, mas sim por letra maiúscula
          na pirimeira letra de todas as palavras subsequentes, SEM espaço
          entre elas)
constantes: escrever no estilo PascalCase (primeira letra maiúscula, e, a cada
            palavra nova, separação não por espaço, mas sim por letra maiúscula 
            na pirimeira letra de todas as palavras subsequentes, SEM espaço
            entre elas)
if else's - não seria errado usar chaves sempre, mas se o bloco de código do if
            else só tem uma linha, convém escevê-lo na mesma linha e sem {}

- aprenderei mais convenções com o passar do tempo
- ter bom senso com as linhas vazias para separar blocos de código e saber como 
comentar os códigos da forma certa usando 
/* 
*/
- muito provavelmente, no entanto, como estou no basiquinho, a cada bloco de 
código, farei comentarios breves utilizando // para lembrar o que aquela parte 
deveria fazer

vocabulário
...[] - colchetes inferem em uma matriz. Matriz é uma coleção de um mesmo 
        tipo de dado.
new - cria um novo objeto para um termo de referência que o precede
.Length - propriedade que pode ser atribuída a uma string e conta o tamanho dela
          L e.g.: Matrix.length conta quantos elementos estão na matriz "Matrix"
Random - atribui á variavel posposta a ela o atributo de ser int e de ser                   
         aleatório. Ou seja, cria uma nova instância dotada da classe '.Random'
.Next() - dados 2 valores dentro dos seus parênteses, mínimo e máximo, esse 
          método gera um valor dentro do range especificado mediado pela
          instância '.Random' já declarada e anteposta a ela
.Write() - output linear
.WriteLine() - output linear + enter
.Trim() - retira espaços da string
.TrimStart() - retira apenas espaços à esqueda da string
.TrimEnd() - retira apenas espaços à direita da string
.ToLower() - reescreve uma string com todas as letras minúsculas
.ToUpper() - reescreve uma string com todas as letras maiúsculas
.Contains() - checa se há um algo, declarado dentro dele, em um outro algo
.IndexOf() - acha a primeira ocorrência de algo
.ToString() - conversão de expansão que converte dados em ums string
.Substring(start, length) - pega apenas parte de uma string (começando pela
                            posição do "start", com o tamanho de "length"
.Remove() - corta parte da string fora exatamente como o .Substring()
foreach (...) - consegue acessar todos os elementos de uma matriz, um a um, e
                os atribui a variável que foi nomeada
switch(...){} - utilizando a variável em parênteses, atribui casos com valores
                fixos e atuando como if elses
case ...: - casos que fazem algo dependendo do valor atribuído à variável e
            declarado após
break; - encerra o loop e sai do laço
.Split() - pega a string e separa ela a depender de um char
for(...) {} - similar ao foreach. utilia um index para criar um sistema de
              numeração. pode ser usado com Matrizes.Length
index (i) - no for, é, normalmente, adicionado da seguinte maneira:
            e.g.: i = 0; i < 10; i++;
            i = 0 é o inicializador. É a partir desse número que a contagem 
                  começa e sofre as condições e incrementos
            i < 10 é a condição para o elemento seguinte. Enquanto i é....
            i ++ é o incremento. Satisfeitas as condições acima, +1
.Join() - concatena vários valores e os separa a depender de outra string
List<T> - Matrix variável de elementos
.Add() - adiciona o que quiser na lista 
do{...} while() - itera o bloco de código uma vez antes de avaliar uma 
                  expressão booliana e potencialmente sair da iteração
while() - avalia uma expressão booliana imediatamente, itera o bloco e
          avalia essa mesma expressão depois dessa iteração para tentar 
          sair da iteração.
continue; - pula os processos para ir direto para a avaliação da expressão

