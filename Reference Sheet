
tipos de dados:
string - inferem sequência de letras, "" VERMELHO (Cor do IntelliSense)
char - infere um único caractere, '' VERMELHO (Cor do IntelliSense)
int - infere um número pertencente aos inteiros (Z), () (o parênteses pode ser           omitido) VERDE (Cor do IntelliSense) 
Float - número com precisão baixa de decimais, porém, rapida - 0.123456789F (1-9)
        VERDE
Double - padrão da linguagem. precisão mediana - 0.1234567890123456789 (1-19) VERDE
Decimal - precisão alta, lento - 0.12345678901234567890123456789m (1-29) VERDE
var - variável genérica e adaptável a qualquer tipo de dado

formatação de Hard-Code
\n - Enter
\t - tab
\" Lorem ipsum \" - usar aspas duplas dentro do código
\\ Lorem ipsum \\ - usar barras invertidas dentro do código
@ - verbatim, ignora a maioria dos caracteres de escapes para aumentar a 
    legibilidade, além de preservar espaços.
  L nota: "duplicar ""aspas duplas"" para usá-lo"
$ - interpolação - utiliza-se para mencionar variáveis entre chaves {}
  L nota: deve precede o verbatim, caso houver
+ - adição ou concatenação
- - subtração
+= - soma o mesmo elemento com mais algo
-= - subrtrai o mesmo elemento com algo
++ - shortcut para += 1
-- - shortcut para -= 1
/ - divisão (cuidado, usar float, double ou decimal)
/= divide o mesmo elemento com algo
* - multiplicação 
*= multiplica o mesmo elemento com algo
% - cálculo do resto da divisão dos números
= - atribuição
== - checa igualdades
!= - checa desigualdades
> - compara o termo da esquerda, supondo ele maior que o da direita
< - compara o termo da esquerda, supondo ele menor que o da direita
? - Feita a comparação, o resultado "True" atribui o resultado que o sucede
: - Feita a comparação, o resultado "False" atribui o resultado que o sucede.
  L ":" vem depois de "?"
|| - ou, serve apenas para comparações booleanas
&& - e, serve apenas para comparações booleanas
! - não, serve apenas para comparações booleanas
or - patter matching lógico ou, para switch cases 
and - patter matching lógico e, para switch cases 
not - patter matching lógico não, para switch cases 

convenções

variável: escrever no estilo camelCase (primeira letra minúscula, e, a cada palavra
          nova, separação não por espaço, mas sim por letra maiúscula na pirimeira
          letra de todas as palavras subsequentes, SEM espaço entre elas)
constantes: escrever no estilo PascalCase (primeira letra maiúscula, e, a cada 
            palavra nova, separação não por espaço, mas sim por letra maiúscula na
            pirimeira letra de todas as palavras subsequentes, SEM espaço entre                elas)
if else's - não seria errado usar chaves sempre, mas se o bloco de código do if
            else só tem uma linha, convém escevê-lo na mesma linha e sem {}

- aprenderei mais convenções com o passar do tempo
- ter bom senso com as linhas vazias para separar blocos de código e saber como comentar os códigos da forma certa usando 
/* 
*/
- muito provavelmente, no entanto, como estou no basiquinho, a cada bloco de código, farei comentarios breves utilizando // para lembrar o que aquela parte deveria fazer

vocabulário
...[] - colchetes inferem em uma matriz. Matriz é uma coleção de um mesmo tipo de          dado.
new - cria um novo objeto para um termo de referência que o precede
.Length - propriedade que pode ser atribuída a uma string e conta o tamanho dela
          L e.g.: Matrix.length conta quantos elementos estão na matriz "Matrix"
Random - atribui á variavel posposta a ela o atributo de ser int e de ser                   aleatório. Ou seja, cria uma nova instância dotada da classe '.Random'
.Next() - dados 2 valores dentro dos seus parênteses, mínimo e máximo, esse método           gera um valor dentro do range especificado mediado pela instância                  '.Random' já declarada e anteposta a ela
.Write() - output linear
.WriteLine() - output linear + enter
.Trim() - retira espaços da string
.ToLower() - reescreve uma string com todas as letras minúsculas
.ToUpper() - reescreve uma string com todas as letras maiúsculas
.Contains() - checa se há um algo, declarado dentro dele, em um outro algo
foreach (...) - consegue acessar todos os elementos de uma matriz, um a um, e
                os atribui a variável que foi nomeada
switch(...){} - utilizando a variável em parênteses, atribui casos com valores
                fixos e atuando como if elses
case ...: - casos que fazem algo dependendo do valor atribuído à variável e
            declarado após
break; - separa cases
.Split() - pega a string e separa ela a depender de um char
for(...) {} - similar ao foreach. utilia um index para criar um sistema de
              numeração. pode ser usado com Matrizes.Length
index (i) - no for, é, normalmente, adicionado da seguinte maneira:
            e.g.: i = 0; i < 10; i++;
            i = 0 é o inicializador. É a partir desse número que a contagem começa
            i < 10 é a condição para o elemento seguinte. Enquanto i é....
            i ++ é o incremento. Satisfeitas as condições acima, +1
.Join() - concatena vários valores e os separa a depender de outra string
List<T> - Matrix variável de elementos
.Add() - adiciona o que quiser na lista 
